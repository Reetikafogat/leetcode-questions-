QUESTION:Given an integer array nums, find the subarray with the largest sum, and return its sum.
Example 1:

Input: nums = [-2,1,-3,4,-1,2,1,-5,4]
Output: 6
Explanation: The subarray [4,-1,2,1] has the largest sum 6.

BRUTE FORCE APPROCH: apply 3 nested for loops i=0 to n , j=i to n-->sum =0; , k=i to j --> this is for summing subarray elements till j and updating maximum if sum>maxi;

BETTER APPROACH: two loops only .T.C=o(n2) , S.C=o(1)
class Solution {
public:
    int maxSubArray(vector<int>& nums) {
        int maxi=INT_MIN;
        for(int i=0;i<nums.size();i++){
            int sum=0;
            for(int j=i;j<nums.size();j++){
                sum+=nums[j];
            if (sum>maxi){
                maxi=sum;
            }
            }
        }
        return maxi;
        
    }
};

OPTIMAL APPROACH:kadane's algorithm ,T.C=o(n),S.C=o(1) 
Kadane's Algorithm is a famous Dynamic Programming approach used to find the maximum sum of a contiguous subarray 
within a one-dimensional array of numbers. It runs in O(n) time, making it highly efficient.
âœ… Kadane's Algorithm: Intuition
The idea is to keep track of the current sum of the subarray, and reset it if it becomes negative, because a negative sum will reduce the sum of any future subarray.
CODE:
public:
    int maxSubArray(vector<int>& nums) {
        int maxi=INT_MIN;
        int sum=0;
        for(int i=0;i<nums.size();i++){
            if(sum<0){
                sum=0;
            }
            sum+=nums[i];
            if(sum>maxi){
                maxi=sum;
            }
        }
        return maxi;  
    }
};
